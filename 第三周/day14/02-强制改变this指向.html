<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div>divdivdiv</div>
  </body>
</html>
<script>
  /*
    强制改变this指向
        - 不管this指向哪， 我让this指向哪里，它就要指向哪里 

    1. call 
        - 语法  函数名.call(参数)
        - 参数
              -> 参数1 该函数内的this指向(新指向)
              -> 参数2 依次给函数进行形参赋值
        - 特点 立即调用函数
    2. apply
        - 语法  函数名.apply(参数1, 参数2)
        - 参数
            -> 参数1  该函数内的this指向(新指向)
            -> 参数2  是一个数组，内部的每一项都是给函数形参赋值
        - 特点 立即调用函数
    3. bind 
        - 语法  函数名.bind(参数)
        - 参数
            -> 参数1  该函数内的this指向(新指向)
            -> 从参数2开始，依次给函数的形参赋值 
        - 特点
            1. 不会立即调用函数，而是返回一个新函数
            2. 有一个返回值，是一个和原始函数一模一样的新函数，只不过被锁死了this
  */

  // 1. call
  //   function fn(a, b) {
  //     console.log(this);
  //     console.log(a, b);
  //   }
  //   //   fn(100, 200);
  //   //   fn.call(document);
  //   var obj = { a: 100, b: 200 };
  //   //   fn.call(obj, 1000);
  // fn.call(obj, 1000, 2000, 3000);

  // 2. apply
  //   function fn(a, b) {
  //     console.log(this);
  //     console.log(a, b);
  //   }
  //   //   fn(100, 200);
  //   //   fn.apply(document, []);
  //   fn.apply(document, [1000, 2000, 3000]);

  // 3. bind
  //   function fn(a, b) {
  //     console.log(this);
  //     console.log(a, b);
  //   }
  //   fn.bind(document, 1000, 2000);
  // 把bind的返回值执行
  //   var res = fn.bind(document, 1000, 2000);
  //   res();
  // 把bind的返回值执行
  //   fn.bind(document, 1000, 2000)();

  // 练习

  var obj = {
    username: "tom",
  };
  function fn(a, b) {
    console.log(this);
    console.log(a, b);
  }
  //   setTimeout(fn, 2000);

  // 需要把定时器中的函数的this指向 为obj , 使用bind
  //   setTimeout(fn.bind(obj), 2000);

  //  document.querySelector("div").onclick = fn;
  // 需要把事件处理函数中的this指向obj
  document.querySelector("div").onclick = fn.bind(obj);
</script>
