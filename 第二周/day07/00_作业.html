<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
</html>
<script>
  /*
      1. 已知一个排序好的数组
        - 将数组按照原有顺序插入到数组内

        var origin = [ 10, 20, 30, 40, 50 ]
        var n = 11

        // 结果: [ 10, 11, 20, 30, 40, 50 ]

        - 选做: 把该操作封装成函数
      2. 封装函数, 把数组进行放大十倍的操作
        function map(arr) {

        }
        // 将来使用的时候
        var arr = [ 100, 200, 300 ]
        var res = map(arr)

        - 要求: 函数的返回值需要是一个新数组

      3. 数组去重
        - 去除数组内的重复项
  */

  // 作业1
  var origin = [50, 40, 30, 20, 10]
  var n = 11
  // 方法1 先放进去，再排序
  // 1. 放进去
  //   origin.push(n)
  // 2. 排序 判断原来是升序还是降序
  // 用[0]  [arr.length-1] 比较
  //   var type = origin[0] < origin[origin.length - 1] ? "升序" : "降序"
  //   switch (type) {
  //     case "升序":
  //       origin.sort(function (a, b) {
  //         return a - b
  //       })
  //       break
  //     case "降序":
  //       origin.sort(function (a, b) {
  //         return b - a
  //       })
  //       break
  //   }
  //   console.log(origin)

  // 方法2 ，先判断是升序还是降序，找到要插入的位置
  var type = origin[0] < origin[origin.length - 1] ? "升序" : "降序"
  for (var i = 0; i < origin.length; i++) {
    if (type === "升序") {
      if (origin[i] > n) {
        index = i
        break
      }
    } else {
      if (origin[i] < n) {
        index = i
        break
      }
    }
  }

  origin.splice(index, 0, n)
  console.log(origin)
</script>
